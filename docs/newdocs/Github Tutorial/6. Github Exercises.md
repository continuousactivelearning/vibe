## Case Study 1 Exercises: Setting Up a Project

-   Create a new  **public**  repository named  `my-blog-practice`, initialize with a README, then clone it locally using both GitHub Desktop and the CLI.
    
-   In your local clone, build a blog folder structure (`content/`,  `assets/`,  `drafts/`) and add a  `.gitignore`  that excludes system files and build artifacts. Commit and push these changes with a descriptive message.
    
-   Add a new Markdown post under  `content/`, commit only that file, then view your commit history in GitHub Desktop.
    
-   Introduce an unwanted file (e.g.  `temp.log`), verify it’s untracked, then update  `.gitignore`, commit the change, and confirm the file no longer appears in “Changes.”
    

## Case Study 2 Exercises: Branching & Merging Workflow

-   Create two branches off  `main`:  `feature/button`  and  `feature/theme`. In each branch, modify the same CSS file to add a button style and a theme color, respectively. Commit and push both branches.
    
-   Open one branch as a  **draft**  pull request, then convert it to a regular PR once you’re ready for review.
    
-   Attempt to merge the first PR, then merge the second PR via the web UI. Manually resolve the merge conflict in the CSS file, commit the resolution, and complete the merge.
    
-   Back in your terminal, perform a  **fast-forward**  merge of a short-lived branch and a  **squash**  merge of a longer-lived branch using GitHub CLI.
    

## Case Study 3 Exercises: Collaboration & Project Management

-   In your repo, create three Issues: label one as  `bug`, one as  `enhancement`, and one as  `question`. Assign each to yourself.
    
-   Set up a  **Project board**  named “Sprint Board” with columns  **To do**,  **In progress**, and  **Done**. Add your Issues as cards, then move one card through the workflow.
    
-   Create a Milestone called “Sprint 1” with a due date one week away and assign two of your Issues to it.
    
-   In the  **Wiki**, add an  **Installation**  page that documents how to clone and start the project, then link to it from your README.
    
-   Enable  **Discussions**, start a “How to contribute?” thread, and post an answer to your own question.
    
-   If using an Organization, create a team, grant it  **Write**  access, and add a collaborator with  **Read**  access only.
    

## Case Study 4 Exercises: Automation & Security

-   Add a CI workflow in  `.github/workflows/ci.yml`  that runs  `npm test`  (or  `pytest`) on every push and PR. Push it and verify the Actions tab shows a passing run.
    
-   Enable CodeQL code scanning and Dependabot alerts. Introduce a known-vulnerable dependency in your manifest, then fix it after Dependabot opens a PR.
    
-   Create a custom release workflow in  `.github/workflows/release.yml`  that uses an auto-tag action to bump versions when  `main`  is pushed. Test by pushing a commit with a version bump in  `package.json`  or  `pyproject.toml`.
    
-   View your repository’s  **Dependency graph**, locate any alerts, and upgrade or remove a flagged package.
    

## Case Study 5 Exercises: Open Source & Advanced Git

-   Fork an external open-source repo, clone your fork, and add  `upstream`  as a remote. Fetch from  `upstream`  and ensure you can merge new commits into your  `main`.
    
-   Identify a small fix commit in  `upstream/main`, cherry-pick it into a new branch in your fork, resolve any conflicts, then push and open a PR upstream.
    
-   On your fork’s  `main`, create an annotated tag following semantic versioning (e.g.,  `v0.1.1-patch`), push it, and draft a GitHub release with release notes.
    
-   On a feature branch with multiple commits, perform an interactive rebase to squash them into a single commit, then force-push the branch to your fork.
