"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7929],{4318:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var s=i(4700);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},4384:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"Express/Dependency Injection","title":"Dependency Injection","description":"Dependency Injection & Inversion of Control","source":"@site/newdocs/Express/10. Dependency Injection.md","sourceDirName":"Express","slug":"/Express/Dependency Injection","permalink":"/vibe/newdocs/Express/Dependency Injection","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/\u2026/newdocs/Express/10. Dependency Injection.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{},"sidebar":"newSidebar","previous":{"title":"Repository Pattern","permalink":"/vibe/newdocs/Express/Repository Pattern"},"next":{"title":"Github Tutorial 1","permalink":"/vibe/newdocs/Github Tutorial/Github Tutorial 1"}}');var t=i(7968),r=i(4318);const o={},c=void 0,l={},a=[{value:"1. Problem Statement",id:"1-problem-statement",level:2},{value:"2. Learning Objectives",id:"2-learning-objectives",level:2},{value:"3. Concept Introduction with Analogy",id:"3-concept-introduction-with-analogy",level:2},{value:"<strong>Analogy: The Clinic\u2019s Reception Desk and Service Providers</strong>",id:"analogy-the-clinics-reception-desk-and-service-providers",level:2},{value:"4. Technical Deep Dive",id:"4-technical-deep-dive",level:2},{value:"<strong>A. What Is Dependency Injection (DI)?</strong>",id:"a-what-is-dependency-injection-di",level:2},{value:"<strong>B. Types of Dependency Injection</strong>",id:"b-types-of-dependency-injection",level:2},{value:"<strong>C. How Does an IoC Container Work?</strong>",id:"c-how-does-an-ioc-container-work",level:2},{value:"<strong>D. Advanced Usage with TypeDI</strong>",id:"d-advanced-usage-with-typedi",level:2},{value:"<strong>E. Why DI/IoC is Essential for Scalable Systems</strong>",id:"e-why-diioc-is-essential-for-scalable-systems",level:2},{value:"<strong>F. Using TypeDI for DI in Node.js/Express</strong>",id:"f-using-typedi-for-di-in-nodejsexpress",level:2},{value:"5. Step-by-Step Data Modeling &amp; Code Walkthrough",id:"5-step-by-step-data-modeling--code-walkthrough",level:2},{value:"6. Challenge",id:"6-challenge",level:2},{value:"7.  Common Pitfalls &amp; Best Practices",id:"7--common-pitfalls--best-practices",level:2},{value:"8. Optional: Programmer\u2019s Workflow Checklist",id:"8-optional-programmers-workflow-checklist",level:2}];function d(e){const n={br:"br",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Dependency Injection & Inversion of Control"}),"\n",(0,t.jsx)(n.h2,{id:"1-problem-statement",children:"1. Problem Statement"}),"\n",(0,t.jsx)(n.p,{children:"Making a Healthcare Appointment System Modular and Testable; Growing Clinic\u2019s Scheduling Headaches"}),"\n",(0,t.jsxs)(n.p,{children:["Sunrise Family Clinic started with a single doctor and a handwritten appointment book.",(0,t.jsx)(n.br,{}),"\n","Now, with multiple doctors, online booking, reminders, and insurance checks:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The code for scheduling, notifications, and billing is tangled together."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Every time a new feature (like SMS reminders) is added, it\u2019s hard to test or swap out without breaking existing code."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"When the clinic wants to try a new SMS provider or add email reminders, developers must rewrite large parts of the system."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Testing is risky, since real notifications go out during every test run."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("img",{src:"https://i.postimg.cc/CMXTgJDH/Express-2.png",width:"300px"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The challenge:"}),(0,t.jsx)(n.br,{}),"\n","How can you design your appointment system so each part (scheduling, notifications, billing) can be developed, tested, and swapped out independently-without breaking the rest of the system?"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-learning-objectives",children:"2. Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"By the end of this tutorial, you will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Understand Dependency Injection (DI) and Inversion of Control (IoC) concepts."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Use a DI container (TypeDI) to manage dependencies in a Node.js/Express app."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Write modular, testable code by injecting services (e.g., notification, billing) instead of hardcoding them."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Swap implementations (e.g., SMS vs. email) without changing business logic."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Write unit tests with mock dependencies."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-concept-introduction-with-analogy",children:"3. Concept Introduction with Analogy"}),"\n",(0,t.jsx)(n.h2,{id:"analogy-the-clinics-reception-desk-and-service-providers",children:(0,t.jsx)(n.strong,{children:"Analogy: The Clinic\u2019s Reception Desk and Service Providers"})}),"\n",(0,t.jsx)(n.p,{children:"Imagine the clinic\u2019s receptionist:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Needs to schedule appointments, send reminders, and process payments."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Instead of calling each service directly, the receptionist uses a  ",(0,t.jsx)(n.strong,{children:"service directory"}),"  (like a switchboard or concierge)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"When the clinic changes SMS providers, the receptionist just updates the directory, not their entire workflow."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Dependency Injection is like this service directory:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Each part of your system asks for the service it needs, not caring who provides it."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"You can swap services (real or mock) easily, for new features or testing."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-technical-deep-dive",children:"4. Technical Deep Dive"}),"\n",(0,t.jsx)(n.h2,{id:"a-what-is-dependency-injection-di",children:(0,t.jsx)(n.strong,{children:"A. What Is Dependency Injection (DI)?"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Dependency Injection"}),"  is a programming technique where an object receives the objects (dependencies) it needs from an external source, rather than creating them itself"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Inversion of Control (IoC):"}),"  Instead of your class controlling how dependencies are created, an external system (the IoC container) takes over that responsibility."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Makes code loosely coupled: your classes depend on  ",(0,t.jsx)(n.em,{children:"interfaces"}),"  (contracts), not concrete implementations."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Enables easy swapping of implementations (e.g., switch from SMS to Email notifications, or from a fake billing service to a real one)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Supports different configurations for different environments (e.g., test, development, production)."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Decouples components (e.g., scheduling doesn\u2019t care how notifications are sent)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Makes code easier to test (inject mocks)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Enables swapping implementations with minimal code changes."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"b-types-of-dependency-injection",children:(0,t.jsx)(n.strong,{children:"B. Types of Dependency Injection"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Constructor Injection (most common and recommended):"}),(0,t.jsx)(n.br,{}),"\n","Dependencies are passed as parameters to the class constructor."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Makes dependencies explicit (you know what\u2019s required)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Enforces required dependencies at creation time (no runtime surprises)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Simplifies mocking for testing (just pass a mock in the constructor)."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Setter Injection:"}),(0,t.jsx)(n.br,{}),"\n","Dependencies are set via setter methods after object creation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Property Injection:"}),(0,t.jsx)(n.br,{}),"\n","Dependencies are set directly on public properties (less common in TypeScript/Node)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Constructor injection is preferred"}),"  for clarity, safety, and testability."]}),"\n",(0,t.jsx)(n.h2,{id:"c-how-does-an-ioc-container-work",children:(0,t.jsx)(n.strong,{children:"C. How Does an IoC Container Work?"})}),"\n",(0,t.jsxs)(n.p,{children:["An  ",(0,t.jsx)(n.strong,{children:"IoC container"}),"  (like TypeDI) manages the creation, configuration, and lifecycle of your services and their dependencies."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Registration:"}),"  You register classes (services) with the container, often with decorators like  ",(0,t.jsx)(n.code,{children:"@Service()"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Resolution:"}),"  When you ask for a service, the container:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Reads the constructor to see what dependencies are needed."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Finds or creates those dependencies (recursively)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Injects them into your class."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Lifecycle Management:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Singleton: One instance for the whole app (default in TypeDI)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Transient: New instance every time."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Scoped: Instance per request/context."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"d-advanced-usage-with-typedi",children:(0,t.jsx)(n.strong,{children:"D. Advanced Usage with TypeDI"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Service Tokens:"}),(0,t.jsx)(n.br,{}),"\n","Instead of using classes directly, you can use tokens (symbols or strings) for even looser coupling."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Factory Functions:"}),(0,t.jsx)(n.br,{}),"\n","Register services using factories for dynamic creation or configuration."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Scoped Containers:"}),(0,t.jsx)(n.br,{}),"\n","Create per-request or per-user containers for request-specific dependencies (e.g., user context, transactions)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Service Groups:"}),(0,t.jsx)(n.br,{}),"\n","Inject arrays of services (e.g., multiple notification handlers)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Resetting and Cleaning Up:"}),(0,t.jsx)(n.br,{}),"\n","Use  ",(0,t.jsx)(n.code,{children:"Container.reset()"}),"  to clear registrations between tests or for hot-reloading."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"e-why-diioc-is-essential-for-scalable-systems",children:(0,t.jsx)(n.strong,{children:"E. Why DI/IoC is Essential for Scalable Systems"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"As your system grows, manual wiring of dependencies becomes error-prone and unmanageable."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"DI containers automate this, making your codebase modular, testable, and adaptable to change"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"f-using-typedi-for-di-in-nodejsexpress",children:(0,t.jsx)(n.strong,{children:"F. Using TypeDI for DI in Node.js/Express"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"1. Install Prerequisites"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install typedi reflect-metadata\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In your ",(0,t.jsx)(n.code,{children:"tsconfig.json"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"experimentalDecorators": true,\n"emitDecoratorMetadata": true\n'})}),"\n",(0,t.jsx)(n.p,{children:"At the top of your entry file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import "reflect-metadata";\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"2. Define Service Interfaces and Implementations"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// notifications/NotificationService.ts\nexport interface NotificationService {\n send(to: string, message: string): Promise<void>;\n}\n\n// notifications/SMSService.ts\nimport { Service } from "typedi";\nimport { NotificationService } from "./NotificationService";\n\n@Service()\nexport class SMSService implements NotificationService {\n async send(to: string, message: string) {\n   console.log(`SMS sent to ${to}: ${message}`);\n }\n}\n\n// notifications/EmailService.ts\nimport { Service } from "typedi";\nimport { NotificationService } from "./NotificationService";\n\n@Service()\nexport class EmailService implements NotificationService {\n async send(to: string, message: string) {\n   console.log(`Email sent to ${to}: ${message}`);\n }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"3. Inject Dependencies"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// appointments/AppointmentService.ts\nimport { Service, Inject } from "typedi";\nimport { NotificationService } from "../notifications/NotificationService";\n\n@Service()\nexport class AppointmentService {\n constructor(\n   @Inject(() => SMSService) private notifier: NotificationService\n ) {}\n\n async bookAppointment(patient: string, time: string) {\n   // ...scheduling logic...\n   await this.notifier.send(patient, `Your appointment is booked for ${time}`);\n   return { status: "confirmed" };\n }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"4. Swap Implementations Easily"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// main.ts\nimport "reflect-metadata";\nimport { Container } from "typedi";\nimport { AppointmentService } from "./appointments/AppointmentService";\nimport { EmailService } from "./notifications/EmailService";\nimport { NotificationService } from "./notifications/NotificationService";\n\n// Use EmailService instead of SMSService\nContainer.set(NotificationService, new EmailService());\n\nconst appointmentService = Container.get(AppointmentService);\nappointmentService.bookAppointment("alice@example.com", "Monday 10am");\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["No change to  ",(0,t.jsx)(n.code,{children:"AppointmentService"}),"  code is needed!"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"5. Test with Mocks"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// tests/AppointmentService.test.ts\nimport { Container } from "typedi";\nimport { AppointmentService } from "../appointments/AppointmentService";\nimport { NotificationService } from "../notifications/NotificationService";\n\nclass MockNotifier implements NotificationService {\n messages: string[] = [];\n async send(to: string, message: string) {\n   this.messages.push(`${to}: ${message}`);\n }\n}\n\ntest("should send notification on booking", async () => {\n const mock = new MockNotifier();\n Container.set(NotificationService, mock);\n\n const service = Container.get(AppointmentService);\n await service.bookAppointment("bob@example.com", "Tuesday 2pm");\n\n expect(mock.messages).toContain("bob@example.com: Your appointment is booked for Tuesday 2pm");\n});\n'})}),"\n",(0,t.jsx)(n.h2,{id:"5-step-by-step-data-modeling--code-walkthrough",children:"5. Step-by-Step Data Modeling & Code Walkthrough"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"A. Setting Up for Flexibility and Growth"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clinic Scenario:"}),(0,t.jsx)(n.br,{}),"\n","The clinic knows it will need to add new notification types (SMS, Email, automated calls) and billing providers (Stripe, insurance, etc.) as it grows. They want to avoid rewriting appointment logic every time."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How DI/TypeDI Solves This:"}),(0,t.jsx)(n.br,{}),"\n","By setting up TypeDI and using interfaces, the clinic can register any notification or billing provider and swap implementations with a single line of code."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Install TypeDI and reflect-metadata:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install typedi reflect-metadata\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Add at the top of your main file:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import "reflect-metadata";\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["Enable decorators in ",(0,t.jsx)(n.code,{children:"tsconfig.json"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'"experimentalDecorators": true,\n"emitDecoratorMetadata": true\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"B. Defining Interfaces: Contracts for Clinic Services"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clinic Scenario:"}),(0,t.jsx)(n.br,{}),"\n","The clinic wants to ensure that all notification and billing services follow a standard contract, so they can add new providers or test with mocks easily."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How DI/TypeDI Solves This:"}),(0,t.jsx)(n.br,{}),"\n","By defining interfaces, the appointment logic doesn\u2019t care how a notification is sent or a bill is processed\u2014only that it happens."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// notifications/NotificationService.ts\nexport interface NotificationService {\n send(to: string, message: string): Promise<void>;\n}\n\n// billing/BillingService.ts\nexport interface BillingService {\n charge(patient: string, amount: number): Promise<void>;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"C. Creating Injectable Implementations: Real-World Providers"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clinic Scenario:"}),(0,t.jsx)(n.br,{}),"\n","The clinic starts with SMS for reminders, but wants to add Email later, and maybe swap in a mock for testing."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How DI/TypeDI Solves This:"}),(0,t.jsx)(n.br,{}),"\n","Each provider is a class marked with  ",(0,t.jsx)(n.code,{children:"@Service()"}),", making it injectable and swappable."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// notifications/SMSService.ts\nimport { Service } from "typedi";\nimport { NotificationService } from "./NotificationService";\n\n@Service()\nexport class SMSService implements NotificationService {\n async send(to: string, message: string) {\n   console.log(`SMS sent to ${to}: ${message}`);\n }\n}\n\n// billing/StripeBillingService.ts\nimport { Service } from "typedi";\nimport { BillingService } from "./BillingService";\n\n@Service()\nexport class StripeBillingService implements BillingService {\n async charge(patient: string, amount: number) {\n   console.log(`Charged $${amount} to ${patient} via Stripe`);\n }\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the clinic wants to add Email or insurance billing, they just add new classes."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"D. Injecting Services into Appointment Logic"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clinic Scenario:"}),(0,t.jsx)(n.br,{}),"\n","The appointment scheduler shouldn\u2019t care how reminders are sent or how billing is processed\u2014it should just ask for those services."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How DI/TypeDI Solves This:"}),(0,t.jsx)(n.br,{}),"\n","The  ",(0,t.jsx)(n.code,{children:"AppointmentService"}),"  receives its dependencies via constructor injection, making it easy to swap them for different environments or tests."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// appointments/AppointmentService.ts\nimport { Service, Inject } from "typedi";\nimport { NotificationService } from "../notifications/NotificationService";\nimport { BillingService } from "../billing/BillingService";\nimport { SMSService } from "../notifications/SMSService";\nimport { StripeBillingService } from "../billing/StripeBillingService";\n\n@Service()\nexport class AppointmentService {\n constructor(\n   @Inject(() => SMSService) private notifier: NotificationService,\n   @Inject(() => StripeBillingService) private billing: BillingService\n ) {}\n\n async bookAppointment(patient: string, time: string, amount: number) {\n   await this.billing.charge(patient, amount);\n   await this.notifier.send(patient, `Your appointment is booked for ${time}`);\n   return { status: "confirmed" };\n }\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the clinic wants to use Email instead of SMS, or a different billing provider, they only change what\u2019s injected, not the business logic."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"E. Swapping Implementations for Growth or Testing"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clinic Scenario:"}),(0,t.jsx)(n.br,{}),"\n","The clinic wants to use Email reminders for some patients, or a mock billing service for testing, without touching appointment logic."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How DI/TypeDI Solves This:"}),(0,t.jsx)(n.br,{}),"\n","You can register any implementation with the container at runtime."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Container } from "typedi";\nimport { AppointmentService } from "./appointments/AppointmentService";\nimport { EmailService } from "./notifications/EmailService";\nimport { NotificationService } from "./notifications/NotificationService";\n\n// Swap to EmailService for notifications\nContainer.set(NotificationService, new EmailService());\n\nconst appointmentService = Container.get(AppointmentService);\nappointmentService.bookAppointment("alice@example.com", "Monday 10am", 50);\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For tests, you can inject a mock service that just logs messages."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"F. Testing with Mocks: Safe, Isolated, and Reliable"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Clinic Scenario:"}),(0,t.jsx)(n.br,{}),"\n","The clinic wants to test appointment booking without sending real notifications or charging real credit cards."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How DI/TypeDI Solves This:"}),(0,t.jsx)(n.br,{}),"\n","Inject a mock service that records calls instead of performing real actions."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'class MockNotifier implements NotificationService {\n messages: string[] = [];\n async send(to: string, message: string) {\n   this.messages.push(`${to}: ${message}`);\n }\n}\n\nclass MockBilling implements BillingService {\n charges: string[] = [];\n async charge(patient: string, amount: number) {\n   this.charges.push(`${patient}: $${amount}`);\n }\n}\n\n// In your test setup\nContainer.set(NotificationService, new MockNotifier());\nContainer.set(BillingService, new MockBilling());\n\nconst service = Container.get(AppointmentService);\nawait service.bookAppointment("bob@example.com", "Tuesday 2pm", 75);\n\n// Assert that the mocks recorded the expected actions\n\nContainer.reset(); // Clean up after test\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No real SMS or billing happens during tests\u2014just logs in memory."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"6-challenge",children:"6. Challenge"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Your Turn!"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Add a  ",(0,t.jsx)(n.code,{children:"BillingService"}),"  interface and a  ",(0,t.jsx)(n.code,{children:"StripeBillingService"}),"  implementation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Inject  ",(0,t.jsx)(n.code,{children:"BillingService"}),"  into  ",(0,t.jsx)(n.code,{children:"AppointmentService"}),"  to charge patients when booking."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Write a test using a mock billing service to verify the charge is made."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"7--common-pitfalls--best-practices",children:"7.  Common Pitfalls & Best Practices"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Pitfall"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Best Practice"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Hardcoding dependencies in services"}),(0,t.jsx)(n.td,{children:"Always inject dependencies via constructor"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Not using interfaces for services"}),(0,t.jsx)(n.td,{children:"Depend on abstractions, not implementations"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Forgetting to reset the container in tests"}),(0,t.jsx)(n.td,{children:"Clean up after each test to avoid side effects"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Over-injecting (too many dependencies)"}),(0,t.jsx)(n.td,{children:"Keep service responsibilities focused"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"8-optional-programmers-workflow-checklist",children:"8. Optional: Programmer\u2019s Workflow Checklist"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Define interfaces for all service dependencies."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Use  ",(0,t.jsx)(n.code,{children:"@Service()"}),"  and  ",(0,t.jsx)(n.code,{children:"@Inject()"}),"  decorators for DI."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Register implementations in the DI container."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Swap implementations for testing or new features."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Write tests using mock services."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Reset the container between tests to avoid leaks"}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);