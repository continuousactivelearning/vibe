"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6025],{4890:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"React/Memoization","title":"Memoization","description":"Memoization in  React: useMemo, useCallback, and  React.memo","source":"@site/newdocs/React/Memoization.md","sourceDirName":"React","slug":"/React/Memoization","permalink":"/vibe/newdocs/React/Memoization","draft":false,"unlisted":false,"editUrl":"https://github.com/your-org/\u2026/newdocs/React/Memoization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"newSidebar","previous":{"title":"Lazy Loading","permalink":"/vibe/newdocs/React/Lazy Loading"},"next":{"title":"Routing","permalink":"/vibe/newdocs/React/Routing"}}');var r=s(7968),t=s(9880);const l={},c=void 0,o={},a=[{value:"1. Problem Statement",id:"1-problem-statement",level:2},{value:"<strong>Case Study: StreamVision Video Dashboard</strong>",id:"case-study-streamvision-video-dashboard",level:2},{value:"2. Learning Objectives",id:"2-learning-objectives",level:2},{value:"3. Concept Introduction with Analogy",id:"3-concept-introduction-with-analogy",level:2},{value:"<strong>Analogy: The StreamVision Control Room</strong>",id:"analogy-the-streamvision-control-room",level:2},{value:"4. Technical Deep Dive",id:"4-technical-deep-dive",level:2},{value:"5. Step-by-Step Data Modeling &amp; Code Walkthrough",id:"5-step-by-step-data-modeling--code-walkthrough",level:2},{value:"6. Interactive Challenge / Mini-Project",id:"6-interactive-challenge--mini-project",level:2},{value:"7. Common Pitfalls &amp; Best Practices",id:"7-common-pitfalls--best-practices",level:2},{value:"Common Pitfalls &amp; Best Practices (React Memoization)",id:"common-pitfalls--best-practices-react-memoization",level:2},{value:"8. Optional: Programmer\u2019s Workflow Checklist",id:"8-optional-programmers-workflow-checklist",level:2}];function d(e){const n={br:"br",code:"code",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Memoization in  React: useMemo, useCallback, and  React.memo"}),"\n",(0,r.jsx)(n.h2,{id:"1-problem-statement",children:"1. Problem Statement"}),"\n",(0,r.jsx)(n.h2,{id:"case-study-streamvision-video-dashboard",children:(0,r.jsx)(n.strong,{children:"Case Study: StreamVision Video Dashboard"})}),"\n",(0,r.jsx)(n.p,{children:"StreamVision is a video analytics dashboard:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"It displays live video feeds, analytics charts, and user comments."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Some components (like charts and video overlays) are expensive to render or compute."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"User interactions (like filtering comments or toggling overlays) can cause unnecessary re-renders, slowing down the UI."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The team wants to optimize performance, especially as the dashboard grows more complex and data-intensive."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)("img",{src:"https://i.postimg.cc/kGzjSRG1/react11.png",alt:"Sample Image",width:"400"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"The challenge:"}),(0,r.jsx)(n.br,{}),"\n","How do you prevent unnecessary recalculations and re-renders in React, ensuring the UI remains fast\u2014even as state and props change frequently?"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-learning-objectives",children:"2. Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this tutorial, you will:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Understand what memoization is and why it matters in React."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"useMemo"}),"  to cache expensive computed values."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"useCallback"}),"  to memoize event handlers and callbacks."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"React.memo"}),"  to prevent unnecessary re-renders of functional components."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Combine these techniques for optimal performance in real-world apps."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Avoid common pitfalls (over-memoization, stale closures)."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-concept-introduction-with-analogy",children:"3. Concept Introduction with Analogy"}),"\n",(0,r.jsx)(n.h2,{id:"analogy-the-streamvision-control-room",children:(0,r.jsx)(n.strong,{children:"Analogy: The StreamVision Control Room"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useMemo"}),"  is like a results whiteboard: If you\u2019ve already done a complex calculation (like analyzing a video feed), you write the result on the board and reuse it until the inputs change."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useCallback"}),"  is like a phone directory: You keep the same phone number (function reference) for callbacks, so you don\u2019t have to reprint the directory every time someone\u2019s name changes."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"React.memo"}),"  is like a smart camera operator: They only update the camera angle (re-render) if the scene actually changes, not just because someone walked into the control room."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-technical-deep-dive",children:"4. Technical Deep Dive"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"A. What Is Memoization in React?"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Memoization"}),"  is the process of caching the result of a function so it doesn\u2019t need to be recomputed unless its inputs change."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"In React, memoization prevents unnecessary recalculations and re-renders, improving performance\u2014especially in large or complex UIs."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"B. useMemo: Memoizing Expensive Computations"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"When you have a computation that is expensive (heavy calculation, large filtering, etc.)."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"When the computed value is used in rendering and only depends on specific props or state."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useMemo } from 'react';\n\nconst ExpensiveChart = ({ data }) => {\n  const processedData = useMemo(() => {\n    // Heavy computation here\n    return computeAnalytics(data);\n  }, [data]); // Only recompute if data changes\n\n  return <Chart data={processedData} />;\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How It Works"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useMemo"}),"  takes a function and a dependency array."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"It only recomputes the value if dependencies change."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Otherwise, it returns the cached value from the last render."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pitfalls"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Don\u2019t use  ",(0,r.jsx)(n.code,{children:"useMemo"}),"  for every value\u2014only for expensive computations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If dependencies are unstable (e.g., new object/array each render), memoization is ineffective."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"C. useCallback: Memoizing Functions and Event Handlers"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["When passing callbacks to child components that are memoized (e.g., with  ",(0,r.jsx)(n.code,{children:"React.memo"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["When the callback is used in a dependency array (e.g., in  ",(0,r.jsx)(n.code,{children:"useEffect"}),")."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useCallback } from 'react';\n\nconst VideoControls = ({ onPlay, onPause }) => (\n <div>\n   <button onClick={onPlay}>Play</button>\n   <button onClick={onPause}>Pause</button>\n </div>\n);\n\nconst Dashboard = () => {\n const [playing, setPlaying] = React.useState(false);\n\n const handlePlay = useCallback(() => setPlaying(true), []);\n const handlePause = useCallback(() => setPlaying(false), []);\n\n return <VideoControls onPlay={handlePlay} onPause={handlePause} />;\n};\n\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How It Works"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useCallback"}),"  returns the same function reference unless dependencies change."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Prevents child components from re-rendering due to new function props."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pitfalls"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Overusing  ",(0,r.jsx)(n.code,{children:"useCallback"}),"  can add complexity with little benefit if the function is cheap or the child isn\u2019t memoized."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Be careful with dependencies\u2014stale closures can occur if dependencies are missing."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"D. React.memo: Memoizing Functional Components"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"When to Use"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"For pure functional components that render the same output given the same props."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"To prevent re-rendering unless props actually change."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Syntax"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React from 'react';\n\nconst CommentList = React.memo(({ comments }) => {\n  console.log('Rendering CommentList');\n  return (\n    <ul>\n      {comments.map((c) => (\n        <li key={c.id}>{c.text}</li>\n      ))}\n    </ul>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"How It Works"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"React.memo"}),"  wraps a component and only re-renders it if its props change (shallow comparison)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"You can provide a custom comparison function for complex props."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pitfalls"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["If props are new objects/arrays each render, memoization won\u2019t help\u2014use  ",(0,r.jsx)(n.code,{children:"useMemo"}),"  or  ",(0,r.jsx)(n.code,{children:"useCallback"}),"  to stabilize them."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Not useful for components with side effects or non-deterministic rendering."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"E. Combining All Three for Maximum Performance"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"useMemo"}),"  for expensive values."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"useCallback"}),"  for event handlers passed to memoized children."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"React.memo"}),"  for pure, presentational components."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-step-by-step-data-modeling--code-walkthrough",children:"5. Step-by-Step Data Modeling & Code Walkthrough"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"A. Memoizing Expensive Chart Data"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useMemo } from 'react';\n\nfunction computeAnalytics(data) {\n  // Simulate heavy computation\n  return data.reduce((acc, item) => acc + item.value, 0);\n}\n\nconst AnalyticsChart = ({ data }) => {\n  const analytics = useMemo(() => computeAnalytics(data), [data]);\n  return <div>Analytics Value: {analytics}</div>;\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"B. Memoizing Event Handlers with useCallback"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useCallback, useState } from 'react';\n\nconst FilterInput = React.memo(({ onFilter }) => {\n  return <input onChange={e => onFilter(e.target.value)} placeholder=\"Filter comments...\" />;\n});\n\nconst CommentsPanel = ({ comments }) => {\n  const [filter, setFilter] = useState('');\n  const filtered = useMemo(\n    () => comments.filter(c => c.text.includes(filter)),\n    [comments, filter]\n  );\n\n  // Memoize setFilter to avoid unnecessary re-renders of FilterInput\n  const handleFilter = useCallback(setFilter, []);\n\n  return (\n    <div>\n      <FilterInput onFilter={handleFilter} />\n      <ul>\n        {filtered.map(c => <li key={c.id}>{c.text}</li>)}\n      </ul>\n    </div>\n  );\n};\n\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"C. Memoizing Components with React.memo"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const VideoOverlay = React.memo(({ overlays }) => {\n  return (\n    <div>\n      {overlays.map(o => (\n        <span key={o.id}>{o.label}</span>\n      ))}\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"6-interactive-challenge--mini-project",children:"6. Interactive Challenge / Mini-Project"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Your Turn!"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Create a  ",(0,r.jsx)(n.code,{children:"TagList"}),"  component that:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Receives a list of tags and a filter string."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Uses  ",(0,r.jsx)(n.code,{children:"useMemo"}),"  to compute the filtered list."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Is wrapped in  ",(0,r.jsx)(n.code,{children:"React.memo"}),"  to avoid unnecessary re-renders."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Create a  ",(0,r.jsx)(n.code,{children:"TagInput"}),"  component that:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Accepts a memoized  ",(0,r.jsx)(n.code,{children:"onAddTag"}),"  callback via  ",(0,r.jsx)(n.code,{children:"useCallback"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Only re-renders when the callback or input value changes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Show how changing unrelated state in the parent does  ",(0,r.jsx)(n.strong,{children:"not"}),"  re-render the memoized  ",(0,r.jsx)(n.code,{children:"TagList"}),"  or  ",(0,r.jsx)(n.code,{children:"TagInput"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"7-common-pitfalls--best-practices",children:"7. Common Pitfalls & Best Practices"}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls--best-practices-react-memoization",children:"Common Pitfalls & Best Practices (React Memoization)"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Pitfall"}),(0,r.jsx)(n.th,{children:"Best Practice"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Overusing memoization"}),(0,r.jsx)(n.td,{children:"Only memoize expensive or frequently-changing values"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Unstable dependencies"}),(0,r.jsx)(n.td,{children:"Use stable references for objects/arrays"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Missing dependencies in hooks"}),(0,r.jsx)(n.td,{children:"Always include all dependencies"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Stale closures in callbacks"}),(0,r.jsx)(n.td,{children:"Ensure dependencies are up-to-date"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Memoizing impure or side-effectful functions"}),(0,r.jsx)(n.td,{children:"Only memoize pure computations"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"8-optional-programmers-workflow-checklist",children:"8. Optional: Programmer\u2019s Workflow Checklist"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"useMemo"}),"  for expensive computations in render."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"useCallback"}),"  for event handlers passed to memoized children."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use  ",(0,r.jsx)(n.code,{children:"React.memo"}),"  for pure, presentational components."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Profile with React DevTools to find real performance bottlenecks."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Avoid memoizing everything\u2014measure before optimizing."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},9880:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>c});var i=s(4700);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);